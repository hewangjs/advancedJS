<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
</head>
<body>
	<script>
	//构造函数、原型对象、实例三者之间的指向关系
	function Person(){

	}
	
	Person.prototype.name="wanghe";
	Person.prototype.age=29;
	Person.prototype.jsb="Software Engineer";
	Person.prototype.sayName=function(){
		console.log(this.name);
	};
	//Person构造函数有一个prototype属性，指向这个函数的原型对象 Person.prototype-->Person Prototype
	//原型对象有一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针
	//Person.prototype.constructor--->function Person(){}
	console.log(Person.prototype)
	console.log(typeof Person.prototype);
	console.log(Person.prototype.constructor)
	console.log(typeof Person.prototype.constructor)

	//实例内部包含一个指针[[Prototype]],指向构造函数的原型对象，没有标准的方式访问，但是Firefox、Safari和Chrom
	//支持属性__proto__
	var person1=new Person();
	person1.sayName();
	var person2=new Person();
	person2.sayName();
	console.log(person1.sayName==person2.sayName);
	console.log(person1.__proto__)
	console.log(person2.__proto__)
	console.log(person1.__proto__==person2.__proto__)//true
	console.log(person1.__proto__==Person.prototype)//实例指向的原型对象和构造函数指向的原型对象是同一个
	//isPrototypeOf()方法来确定对象之间是否存在某种关系，从本质上讲[[Prototype]]即__proto__指向调用
	//isPrototypeOf()方法的对象（Person.prototype），那么这个方法返回true
	console.log(Person.prototype.isPrototypeOf(person1));
	console.log(Person.prototype.isPrototypeOf(person2));
	//Object.getPrototypeOf()返回[[Prototype]]的值
	console.log(Object.getPrototypeOf(person1)==Person.prototype);
	console.log(Object.getPrototypeOf(person1).name);
	</script>
</body>
</html>